import { inject, injectable } from "inversify";
import IBackendPort, {
  ElementDataParams,
  GetWorldDataParams,
  ScoreH5PElementParams,
  UserCredentialParams,
} from "../../Application/Ports/Interfaces/IBackendPort";
import BackendWorldTO from "../../Application/DataTransferObjects/BackendWorldTO";
import CourseListTO from "../../Application/DataTransferObjects/CourseListTO";
import LearningElementScoreTO from "../../Application/DataTransferObjects/LearningElementScoreTO";
import LearningWorldStatusTO from "../../Application/DataTransferObjects/LearningWorldStatusTO";
import AdaptivityElementQuestionSubmissionTO from "../../Application/DataTransferObjects/AdaptivityElement/AdaptivityElementQuestionSubmissionTO";
import AdaptivityElementQuestionResponse from "./Types/AdaptivityElementQuestionResponse";
import AdaptivityElementStatusResponse from "./Types/AdaptivityElementStatusResponse";
import { BackendAvatarConfigTO } from "../../Application/DataTransferObjects/BackendAvatarConfigTO";
import BackendAdapterUtils from "./BackendAdapterUtils";
import AWT from "./Types/AWT";
import { ComponentID } from "../../Domain/Types/EntityTypes";
import PORT_TYPES from "../../DependencyInjection/Ports/PORT_TYPES";
import type ILocalStoragePort from "../../Application/Ports/Interfaces/ILocalStoragePort";

/**
 * WorldsIndex structure as generated by extractLearningWorlds.js
 */
interface WorldsIndex {
  worlds: Array<{
    worldID: number;
    worldName: string;
    worldFolder: string;
    description?: string;
    elementCount?: number;
  }>;
}

/**
 * FileBasedBackendAdapter
 *
 * Loads learning worlds from the public/LearningWorlds/ directory.
 * Expects worlds to be extracted by the extractLearningWorlds.js script.
 *
 * Structure:
 * public/LearningWorlds/
 *   ├── worlds.json              // Index of all available worlds
 *   └── {WorldName}/             // Each world in its own folder
 *       ├── world.json           // AWT/ATF data
 *       └── elements/
 *           ├── {elementId}.jpg  // Elements by ID
 *           ├── {elementId}.pdf
 *           └── {elementId}/     // H5P folders
 *
 * This adapter implements IBackendPort and provides a file-based alternative
 * to the real BackendAdapter (API) and MockBackendAdapter (hardcoded data).
 */
@injectable()
export default class FileBasedBackendAdapter implements IBackendPort {
  private worldsIndex: WorldsIndex | null = null;
  private worldCache: Map<number, AWT> = new Map();
  private baseUrl: string;

  constructor(
    @inject(PORT_TYPES.ILocalStoragePort)
    private localStoragePort: ILocalStoragePort,
  ) {
    // Base URL for fetching files from public folder
    const publicUrl = process.env.PUBLIC_URL || "";
    this.baseUrl = window.location.origin + publicUrl + "/LearningWorlds/";
  }

  /**
   * Loads the worlds.json index file
   */
  private async loadWorldsIndex(): Promise<void> {
    if (this.worldsIndex) return; // Already loaded

    try {
      // Add cache buster to ensure we get the latest worlds.json
      const cacheBuster = `?t=${Date.now()}`;
      const url = this.baseUrl + "worlds.json" + cacheBuster;
      console.log(`FileBasedBackendAdapter: Loading worlds.json from ${url}`);

      const response = await fetch(url, {
        cache: "no-store", // Force bypass cache
        headers: {
          "Cache-Control": "no-cache",
          Pragma: "no-cache",
        },
      });

      if (!response.ok) {
        throw new Error(
          `Failed to load worlds.json: ${response.status} ${response.statusText}`,
        );
      }

      this.worldsIndex = await response.json();
      console.log(
        `FileBasedBackendAdapter: Loaded ${this.worldsIndex!.worlds.length} worlds:`,
        this.worldsIndex!.worlds.map((w) => w.worldName),
      );
    } catch (error) {
      console.error(
        "FileBasedBackendAdapter: Error loading worlds.json",
        error,
      );
      // Fallback: empty worlds list
      this.worldsIndex = { worlds: [] };
    }
  }

  /**
   * Forces reload of worlds.json (useful after importing new worlds)
   */
  public async reloadWorldsIndex(): Promise<void> {
    this.worldsIndex = null;
    this.worldCache.clear();
    await this.loadWorldsIndex();
  }

  /**
   * Loads a world.json file for a specific world
   */
  private async loadWorldData(worldID: number): Promise<AWT> {
    // Check cache first
    if (this.worldCache.has(worldID)) {
      return this.worldCache.get(worldID)!;
    }

    // Ensure index is loaded
    await this.loadWorldsIndex();

    // Find world info
    const worldInfo = this.worldsIndex!.worlds.find(
      (w) => w.worldID === worldID,
    );

    if (!worldInfo) {
      throw new Error(
        `World with ID ${worldID} not found in worlds.json. Available worlds: ${this.worldsIndex!.worlds.map((w) => w.worldID).join(", ")}`,
      );
    }

    // Fetch world.json
    const worldUrl = this.baseUrl + worldInfo.worldFolder + "/world.json";

    try {
      const response = await fetch(worldUrl);
      if (!response.ok) {
        throw new Error(
          `Failed to load world.json for world ${worldID}: ${response.status} ${response.statusText}`,
        );
      }

      const awt: AWT = await response.json();

      // Cache it
      this.worldCache.set(worldID, awt);

      return awt;
    } catch (error) {
      console.error(
        `FileBasedBackendAdapter: Error loading world ${worldID}`,
        error,
      );
      throw error;
    }
  }

  /**
   * Gets the element source path/URL
   */
  async getElementSource({
    worldID,
    elementID,
  }: ElementDataParams): Promise<string> {
    // Load world data to check element type
    const awt = await this.loadWorldData(worldID);

    // Find world info for folder name
    const worldInfo = this.worldsIndex!.worlds.find(
      (w) => w.worldID === worldID,
    );

    // Find element in AWT
    const element = awt.world.elements.find((el) => el.elementId === elementID);

    if (!element) {
      throw new Error(`Element ${elementID} not found in world ${worldID}`);
    }

    // Check if external URL (LearningElement type has url field)
    const elementWithUrl = element as any;
    if (elementWithUrl.url && elementWithUrl.url.startsWith("http")) {
      return elementWithUrl.url;
    }

    // Adaptivity elements have no separate file - content is embedded in world.json
    if (
      element.elementCategory === "adaptivity" ||
      element.elementFileType === "adaptivity"
    ) {
      // Return empty string or a special marker - adaptivity content is in the element itself
      return "";
    }

    // Construct path to element file
    const elementsPath = this.baseUrl + worldInfo!.worldFolder + "/elements/";

    // Check if H5P (folder) or regular file
    if (
      element.elementCategory === "h5p" ||
      element.elementCategory === "primitiveH5P" ||
      element.elementFileType === "h5p"
    ) {
      // H5P elements are folders
      return elementsPath + elementID;
    }

    // Regular files
    return elementsPath + elementID + "." + element.elementFileType;
  }

  /**
   * Gets available courses/worlds for the user
   */
  async getCoursesAvailableForUser(userToken: string): Promise<CourseListTO> {
    await this.loadWorldsIndex();

    return {
      courses: this.worldsIndex!.worlds.map((world) => ({
        courseID: world.worldID,
        courseName: world.worldName,
      })),
    };
  }

  /**
   * Gets world data (AWT)
   */
  async getWorldData({ worldID }: GetWorldDataParams): Promise<BackendWorldTO> {
    const awt = await this.loadWorldData(worldID);

    // Use existing parser from BackendAdapterUtils
    return BackendAdapterUtils.parseAWT(awt);
  }

  /**
   * Load progress from localStorage for a specific world
   */
  private loadProgressFromLocalStorage(worldID: number): {
    [elementID: number]: { scored: boolean; timestamp: string };
  } {
    const key = `adler_progress_${worldID}`;
    const stored = this.localStoragePort.getItem(key);
    if (!stored) {
      return {};
    }
    try {
      const parsed = JSON.parse(stored);
      return parsed.elements || {};
    } catch (error) {
      console.error("Failed to parse progress from localStorage:", error);
      return {};
    }
  }

  /**
   * Save progress to localStorage for a specific world
   */
  private saveProgressToLocalStorage(
    worldID: number,
    elementID: number,
    scored: boolean,
  ): void {
    const key = `adler_progress_${worldID}`;
    const progress = this.loadProgressFromLocalStorage(worldID);
    progress[elementID] = {
      scored,
      timestamp: new Date().toISOString(),
    };
    this.localStoragePort.setItem(
      key,
      JSON.stringify({
        worldID,
        elements: progress,
      }),
    );
  }

  /**
   * Gets world status (completion state)
   * For file-based backend, progress is loaded from localStorage
   */
  async getWorldStatus(
    userToken: string,
    worldID: number,
  ): Promise<LearningWorldStatusTO> {
    const awt = await this.loadWorldData(worldID);
    const progress = this.loadProgressFromLocalStorage(worldID);

    // Return elements with their completion status from localStorage
    return {
      worldID,
      elements: awt.world.elements.map((element) => ({
        elementID: element.elementId,
        hasScored: progress[element.elementId]?.scored || false,
      })),
    };
  }

  /**
   * Gets element score
   * For file-based backend, check localStorage for score
   */
  async getElementScore({
    elementID,
    worldID,
  }: ElementDataParams): Promise<LearningElementScoreTO> {
    const progress = this.loadProgressFromLocalStorage(worldID);
    return {
      elementID,
      success: progress[elementID]?.scored || false,
    };
  }

  /**
   * Scores an element
   * For file-based backend, scoring is persisted to localStorage
   */
  async scoreElement(
    userToken: string,
    elementID: ComponentID,
    courseID: ComponentID,
  ): Promise<boolean> {
    console.log(
      `FileBasedBackendAdapter: scoreElement - Element ${elementID} in World ${courseID}`,
    );
    this.saveProgressToLocalStorage(courseID, elementID, true);
    return true;
  }

  /**
   * Scores H5P element
   * For file-based backend, scoring is not persisted
   */
  async scoreH5PElement(data: ScoreH5PElementParams): Promise<boolean> {
    console.log(
      `FileBasedBackendAdapter: scoreH5PElement called (not persisted) - H5P ${data.h5pID}`,
    );

    // Basic xAPI evaluation for UI feedback (same logic as MockBackendAdapter)
    const xapiEvent = data.rawH5PEvent;

    const isCompleted =
      xapiEvent.verb?.id === "http://adlnet.gov/expapi/verbs/completed";
    const isAnswered =
      xapiEvent.verb?.id === "http://adlnet.gov/expapi/verbs/answered";

    if (isAnswered || isCompleted) {
      const result = xapiEvent.result;
      if (result) {
        if (typeof result.success === "boolean") {
          return result.success;
        }
        if (result.score && typeof result.score.scaled === "number") {
          return result.score.scaled >= 0.6;
        }
      }
    }

    return false;
  }

  /**
   * Login user
   * For file-based backend, no authentication - return dummy token
   */
  async loginUser(userCredentials: UserCredentialParams): Promise<string> {
    console.log(
      `FileBasedBackendAdapter: Login (no authentication) - User: ${userCredentials.username}`,
    );
    // Return a dummy token
    return "file-based-dummy-token";
  }

  /**
   * Get adaptivity element question response
   * Validates answers against the adaptivityContent in world.json
   */
  async getAdaptivityElementQuestionResponse(
    userToken: string,
    worldID: number,
    submissionData: AdaptivityElementQuestionSubmissionTO,
  ): Promise<AdaptivityElementQuestionResponse> {
    // Load world data
    const awt = await this.loadWorldData(worldID);

    // Find the adaptivity element
    const element = awt.world.elements.find(
      (el: any) => el.elementId === submissionData.elementID,
    ) as any;

    if (!element || !element.adaptivityContent) {
      console.error(`Adaptivity element ${submissionData.elementID} not found`);
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Find the task
    const task = element.adaptivityContent.adaptivityTasks.find(
      (t: any) => t.taskId === submissionData.taskID,
    );

    if (!task) {
      console.error(`Task ${submissionData.taskID} not found`);
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Find the question
    const question = task.adaptivityQuestions.find(
      (q: any) => q.questionId === submissionData.questionID,
    );

    if (!question) {
      console.error(`Question ${submissionData.questionID} not found`);
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Validate user answers
    const choices = question.choices || [];
    let isCorrect = true;
    const gradedAnswers: Array<{ checked: boolean; correct: boolean }> = [];

    submissionData.selectedAnswers.forEach((selected, index) => {
      if (index >= choices.length) {
        gradedAnswers.push({ checked: selected, correct: false });
        if (selected) isCorrect = false;
        return;
      }

      const choice = choices[index];
      const shouldBeSelected = choice.isCorrect === true;

      gradedAnswers.push({
        checked: selected,
        correct: shouldBeSelected,
      });

      // For correct answer: selected must match shouldBeSelected
      if (selected !== shouldBeSelected) {
        isCorrect = false;
      }
    });

    return {
      elementScore: {
        elementId: submissionData.elementID,
        success: isCorrect,
      },
      gradedTask: {
        taskId: submissionData.taskID,
        taskStatus: isCorrect ? "Correct" : "Incorrect",
      },
      gradedQuestion: {
        id: submissionData.questionID,
        status: isCorrect ? "Correct" : "Incorrect",
        answers: gradedAnswers,
      },
    };
  }

  /**
   * Helper method to return default adaptivity response
   */
  private getDefaultAdaptivityResponse(
    submissionData: AdaptivityElementQuestionSubmissionTO,
    isCorrect: boolean,
  ): AdaptivityElementQuestionResponse {
    return {
      elementScore: {
        elementId: submissionData.elementID,
        success: isCorrect,
      },
      gradedTask: {
        taskId: submissionData.taskID,
        taskStatus: isCorrect ? "Correct" : "Incorrect",
      },
      gradedQuestion: {
        id: submissionData.questionID,
        status: isCorrect ? "Correct" : "Incorrect",
        answers: submissionData.selectedAnswers.map((selected) => ({
          checked: selected,
          correct: false,
        })),
      },
    };
  }

  /**
   * Get adaptivity element status
   * For file-based backend, progress is not persisted, always return fresh state
   */
  async getAdaptivityElementStatusResponse({
    elementID,
    worldID,
  }: ElementDataParams): Promise<AdaptivityElementStatusResponse> {
    // Load world data to get adaptivity structure
    const awt = await this.loadWorldData(worldID!);

    // Find the adaptivity element
    const element = awt.world.elements.find(
      (el: any) => el.elementId === elementID,
    ) as any;

    if (!element || !element.adaptivityContent) {
      // Fallback if element not found
      return {
        element: { elementID, success: false },
        questions: [],
        tasks: [],
      };
    }

    // Build task and question structure with "Not Attempted" status
    const tasks = element.adaptivityContent.adaptivityTasks.map(
      (task: any) => ({
        taskId: task.taskId,
        taskStatus: "Not Attempted",
      }),
    );

    const questions: Array<{
      id: number;
      status: string;
      answers: Array<{ checked: boolean; correct: boolean }>;
    }> = [];

    element.adaptivityContent.adaptivityTasks.forEach((task: any) => {
      task.adaptivityQuestions.forEach((question: any) => {
        // Create default answers array based on number of choices
        const defaultAnswers = (question.choices || []).map(() => ({
          checked: false,
          correct: false,
        }));

        questions.push({
          id: question.questionId,
          status: "Not Attempted",
          answers: defaultAnswers,
        });
      });
    });

    return {
      element: {
        elementID,
        success: false,
      },
      questions,
      tasks,
    };
  }

  /**
   * Get avatar configuration
   * For file-based backend, load from localStorage or return default
   */
  async getAvatarConfig(userToken: string): Promise<BackendAvatarConfigTO> {
    const key = "adler_avatar_config";
    const stored = this.localStoragePort.getItem(key);

    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        console.log(
          "FileBasedBackendAdapter: getAvatarConfig - loaded from localStorage",
        );
        return Object.assign(new BackendAvatarConfigTO(), parsed);
      } catch (error) {
        console.error(
          "Failed to parse avatar config from localStorage:",
          error,
        );
      }
    }

    console.log(
      "FileBasedBackendAdapter: getAvatarConfig - returning default avatar",
    );

    // Return default avatar configuration (same as MockBackendAdapter)
    const config = new BackendAvatarConfigTO();

    // Face (texture names)
    config.eyes = "Neural_Eyes_1";
    config.nose = "Nose_1";
    config.mouth = "Mouth_1";
    config.eyebrows = "Brows_1";

    // Hair
    config.hair = "hair-short-vanilla";
    config.beard = "none";
    config.hairColor = 8;

    // Accessories
    config.headgear = "none";
    config.glasses = "none";
    config.backpack = "none";
    config.other = "none";

    // Clothes
    config.shirt = "shirts-hoodie";
    config.shirtColor = 0;
    config.pants = "pants-jeans";
    config.pantsColor = 0;
    config.shoes = "shoes-trainers";
    config.shoesColor = 0;

    // Body
    config.skinColor = 24;
    config.roundness = 0.5;

    return config;
  }

  /**
   * Update avatar configuration
   * For file-based backend, save to localStorage
   */
  async updateAvatarConfig(
    userToken: string,
    avatarConfig: BackendAvatarConfigTO,
  ): Promise<boolean> {
    const key = "adler_avatar_config";
    try {
      this.localStoragePort.setItem(key, JSON.stringify(avatarConfig));
      console.log(
        "FileBasedBackendAdapter: updateAvatarConfig - saved to localStorage",
      );
      return true;
    } catch (error) {
      console.error("Failed to save avatar config to localStorage:", error);
      return false;
    }
  }
}
