import { inject, injectable } from "inversify";
import IBackendPort, {
  ElementDataParams,
  GetWorldDataParams,
  ScoreH5PElementParams,
  UserCredentialParams,
} from "../../Application/Ports/Interfaces/IBackendPort";
import BackendWorldTO from "../../Application/DataTransferObjects/BackendWorldTO";
import CourseListTO from "../../Application/DataTransferObjects/CourseListTO";
import LearningElementScoreTO from "../../Application/DataTransferObjects/LearningElementScoreTO";
import LearningWorldStatusTO from "../../Application/DataTransferObjects/LearningWorldStatusTO";
import AdaptivityElementQuestionSubmissionTO from "../../Application/DataTransferObjects/AdaptivityElement/AdaptivityElementQuestionSubmissionTO";
import AdaptivityElementQuestionResponse from "./Types/AdaptivityElementQuestionResponse";
import AdaptivityElementStatusResponse from "./Types/AdaptivityElementStatusResponse";
import { BackendAvatarConfigTO } from "../../Application/DataTransferObjects/BackendAvatarConfigTO";
import BackendAdapterUtils from "./BackendAdapterUtils";
import AWT from "./Types/AWT";
import { ComponentID } from "../../Domain/Types/EntityTypes";
import PORT_TYPES from "../../DependencyInjection/Ports/PORT_TYPES";
import CORE_TYPES from "../../DependencyInjection/CoreTypes";
import type ILocalStoragePort from "../../Application/Ports/Interfaces/ILocalStoragePort";
import type ILoggerPort from "../../Application/Ports/Interfaces/ILoggerPort";
import { LogLevelTypes } from "../../Domain/Types/LogLevelTypes";
import H5PIndexedDBServer from "../H5PIndexedDBServer/H5PIndexedDBServer";
import type IWorldStorageAdapter from "../../Application/Ports/WorldStoragePort/IWorldStorageAdapter";

/**
 * WorldsIndex structure as generated by extractLearningWorlds.js
 */
interface WorldsIndex {
  worlds: Array<{
    worldID: number;
    worldName: string;
    worldFolder: string;
    description?: string;
    elementCount?: number;
  }>;
}

/**
 * HybridBackendAdapter
 *
 * Hybrid offline-first backend adapter that:
 * 1. First checks IndexedDB (LocalStore) for cached learning worlds
 * 2. Falls back to public/LearningWorlds/ directory if not found in cache
 *
 * This adapter replaces FileBasedBackendAdapter and provides seamless offline support
 * with runtime MBZ import capability via the browser.
 *
 * Structure:
 * - IndexedDB (LocalStore): Imported worlds via MBZ files
 * - public/LearningWorlds/: Pre-extracted worlds from build time
 *
 * This adapter implements IBackendPort and provides a hybrid file-based alternative
 * to the real BackendAdapter (API) and MockBackendAdapter (hardcoded data).
 */
@injectable()
export default class HybridBackendAdapter implements IBackendPort {
  private worldsIndex: WorldsIndex | null = null;
  private worldCache: Map<number, AWT> = new Map();
  private baseUrl: string;

  constructor(
    @inject(PORT_TYPES.ILocalStoragePort)
    private localStoragePort: ILocalStoragePort,
    @inject(PORT_TYPES.IWorldStorageAdapter)
    private worldStorage: IWorldStorageAdapter,
    @inject(CORE_TYPES.ILogger)
    private logger: ILoggerPort,
  ) {
    // Base URL for fetching files from public folder
    const publicUrl = process.env.PUBLIC_URL || "";
    this.baseUrl = window.location.origin + publicUrl + "/LearningWorlds/";

    // Initialize WorldStorageAdapter for IndexedDB access
    this.worldStorage.init().catch((error) => {
      this.logger.log(
        LogLevelTypes.ERROR,
        `HybridBackendAdapter: Failed to initialize WorldStorageAdapter: ${error}`,
      );
    });
  }

  /**
   * Loads the worlds.json index file from public folder
   */
  private async loadWorldsIndex(): Promise<void> {
    if (this.worldsIndex) return; // Already loaded

    try {
      const response = await fetch(this.baseUrl + "worlds.json");
      if (!response.ok) {
        throw new Error(
          `Failed to load worlds.json: ${response.status} ${response.statusText}`,
        );
      }
      this.worldsIndex = await response.json();
    } catch (error) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `HybridBackendAdapter: Error loading worlds.json: ${error}`,
      );
      // Fallback: empty worlds list
      this.worldsIndex = { worlds: [] };
    }
  }

  /**
   * Loads a world.json - HYBRID: Try IndexedDB first, then public folder
   */
  private async loadWorldData(worldID: number): Promise<AWT> {
    // Check cache first
    if (this.worldCache.has(worldID)) {
      return this.worldCache.get(worldID)!;
    }

    // Step 1: Try loading from IndexedDB
    try {
      const worldExists = await this.worldStorage.worldExists(worldID);

      if (worldExists) {
        this.logger.log(
          LogLevelTypes.DEBUG,
          `HybridBackendAdapter: Loading world ${worldID} from IndexedDB`,
        );
        const worldBlob = await this.worldStorage.getFile(
          worldID,
          "world.json",
        );

        if (worldBlob) {
          const worldText = await worldBlob.text();
          const awt: AWT = JSON.parse(worldText);

          // Cache it
          this.worldCache.set(worldID, awt);
          return awt;
        }
      }
    } catch (error) {
      this.logger.log(
        LogLevelTypes.WARN,
        `HybridBackendAdapter: Failed to load from IndexedDB, falling back to public folder: ${error}`,
      );
    }

    // Step 2: Fallback to public folder
    this.logger.log(
      LogLevelTypes.DEBUG,
      `HybridBackendAdapter: Loading world ${worldID} from public folder`,
    );
    await this.loadWorldsIndex();

    const worldInfo = this.worldsIndex!.worlds.find(
      (w) => w.worldID === worldID,
    );

    if (!worldInfo) {
      throw new Error(
        `World with ID ${worldID} not found in worlds.json or IndexedDB. Available worlds: ${this.worldsIndex!.worlds.map((w) => w.worldID).join(", ")}`,
      );
    }

    // Fetch world.json from public folder
    const worldUrl = this.baseUrl + worldInfo.worldFolder + "/world.json";

    try {
      const response = await fetch(worldUrl);
      if (!response.ok) {
        throw new Error(
          `Failed to load world.json for world ${worldID}: ${response.status} ${response.statusText}`,
        );
      }

      const awt: AWT = await response.json();

      // Cache it
      this.worldCache.set(worldID, awt);

      return awt;
    } catch (error) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `HybridBackendAdapter: Error loading world ${worldID}: ${error}`,
      );
      throw error;
    }
  }

  /**
   * Gets the element source path/URL - HYBRID: Try IndexedDB first, then public folder
   */
  async getElementSource({
    worldID,
    elementID,
  }: ElementDataParams): Promise<string> {
    // Load world data to check element type
    const awt = await this.loadWorldData(worldID);

    // Find element in AWT
    const element = awt.world.elements.find((el) => el.elementId === elementID);

    if (!element) {
      throw new Error(`Element ${elementID} not found in world ${worldID}`);
    }

    // Check if external URL (LearningElement type has url field)
    const elementWithUrl = element as any;
    if (elementWithUrl.url && elementWithUrl.url.startsWith("http")) {
      return elementWithUrl.url;
    }

    // Adaptivity elements have no separate file - content is embedded in world.json
    if (
      element.elementCategory === "adaptivity" ||
      element.elementFileType === "adaptivity"
    ) {
      return "";
    }

    // Step 1: Try loading from IndexedDB
    try {
      const worldExists = await this.worldStorage.worldExists(worldID);

      if (worldExists) {
        let elementPath: string;
        const isH5P =
          element.elementCategory === "h5p" ||
          element.elementCategory === "primitiveH5P" ||
          element.elementFileType === "h5p";

        if (isH5P) {
          // For H5P, check if h5p.json exists (main H5P descriptor file)
          elementPath = `elements/${elementID}/h5p.json`;
        } else {
          // Regular files
          elementPath = `elements/${elementID}.${element.elementFileType}`;
        }

        const fileBlob = await this.worldStorage.getFile(worldID, elementPath);

        if (fileBlob) {
          // Use Service Worker for all file types from IndexedDB
          // This provides consistent behavior and avoids blob URL issues
          const h5pServer = H5PIndexedDBServer.getInstance();

          if (isH5P) {
            // For H5P, return the base path (directory)
            const h5pBasePath = h5pServer.getH5PBaseUrl(worldID, elementID);
            return h5pBasePath;
          } else {
            // For regular files (PDFs, images, videos, etc.), return the complete file path
            const filePath = `/indexeddb/world/${worldID}/elements/${elementID}.${element.elementFileType}`;
            return filePath;
          }
        }
      }
    } catch (error) {
      this.logger.log(
        LogLevelTypes.WARN,
        `HybridBackendAdapter: Failed to load element ${elementID} from IndexedDB, falling back to public folder: ${error}`,
      );
    }

    // Step 2: Fallback to public folder
    this.logger.log(
      LogLevelTypes.DEBUG,
      `HybridBackendAdapter: Element ${elementID} loaded from public folder`,
    );

    // Ensure we have world info
    await this.loadWorldsIndex();
    const worldInfo = this.worldsIndex!.worlds.find(
      (w) => w.worldID === worldID,
    );

    if (!worldInfo) {
      throw new Error(`World ${worldID} not found`);
    }

    const elementsPath = this.baseUrl + worldInfo.worldFolder + "/elements/";

    // Check if H5P (folder) or regular file
    if (
      element.elementCategory === "h5p" ||
      element.elementCategory === "primitiveH5P" ||
      element.elementFileType === "h5p"
    ) {
      // H5P elements are folders
      return elementsPath + elementID;
    }

    // Regular files
    return elementsPath + elementID + "." + element.elementFileType;
  }

  /**
   * Gets available courses/worlds for the user - HYBRID: Merge IndexedDB + public folder
   */
  async getCoursesAvailableForUser(userToken: string): Promise<CourseListTO> {
    await this.loadWorldsIndex();

    // Get worlds from public folder
    const publicWorlds = this.worldsIndex!.worlds.map((world) => ({
      courseID: world.worldID,
      courseName: world.worldName,
    }));

    // Get worlds from IndexedDB
    try {
      const indexedDBWorlds = await this.worldStorage.getAllWorlds();
      const indexedDBCourses = indexedDBWorlds.map((world) => ({
        courseID: world.worldID,
        courseName: world.worldName,
      }));

      // Merge and deduplicate by courseID
      const allCourses = [...publicWorlds, ...indexedDBCourses];
      const uniqueCourses = allCourses.filter(
        (course, index, self) =>
          index === self.findIndex((c) => c.courseID === course.courseID),
      );

      return { courses: uniqueCourses };
    } catch (error) {
      this.logger.log(
        LogLevelTypes.WARN,
        `HybridBackendAdapter: Failed to load worlds from IndexedDB: ${error}`,
      );
      // Fallback to public worlds only
      return { courses: publicWorlds };
    }
  }

  /**
   * Gets world data (AWT)
   */
  async getWorldData({ worldID }: GetWorldDataParams): Promise<BackendWorldTO> {
    const awt = await this.loadWorldData(worldID);

    // Use existing parser from BackendAdapterUtils
    return BackendAdapterUtils.parseAWT(awt);
  }

  /**
   * Load progress from localStorage for a specific world
   */
  private loadProgressFromLocalStorage(worldID: number): {
    [elementID: number]: { scored: boolean; timestamp: string };
  } {
    const key = `adler_progress_${worldID}`;
    const stored = this.localStoragePort.getItem(key);
    if (!stored) {
      return {};
    }
    try {
      const parsed = JSON.parse(stored);
      return parsed.elements || {};
    } catch (error) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `Failed to parse progress from localStorage: ${error}`,
      );
      return {};
    }
  }

  /**
   * Save progress to localStorage for a specific world
   */
  private saveProgressToLocalStorage(
    worldID: number,
    elementID: number,
    scored: boolean,
  ): void {
    const key = `adler_progress_${worldID}`;
    const progress = this.loadProgressFromLocalStorage(worldID);
    progress[elementID] = {
      scored,
      timestamp: new Date().toISOString(),
    };
    this.localStoragePort.setItem(
      key,
      JSON.stringify({
        worldID,
        elements: progress,
      }),
    );
  }

  /**
   * Load adaptivity element progress from localStorage for a specific world
   */
  private loadAdaptivityProgressFromLocalStorage(worldID: number): {
    [elementID: number]: {
      tasks: { [taskID: number]: { status: string } };
      questions: {
        [questionID: number]: {
          status: string;
          answers: Array<{ checked: boolean; correct: boolean }>;
        };
      };
    };
  } {
    const key = `adler_adaptivity_progress_${worldID}`;
    const stored = this.localStoragePort.getItem(key);
    if (!stored) {
      return {};
    }
    try {
      const parsed = JSON.parse(stored);
      return parsed.elements || {};
    } catch (error) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `Failed to parse adaptivity progress from localStorage: ${error}`,
      );
      return {};
    }
  }

  /**
   * Save adaptivity element progress to localStorage for a specific world
   */
  private saveAdaptivityProgressToLocalStorage(
    worldID: number,
    elementID: number,
    taskID: number,
    questionID: number,
    questionStatus: string,
    taskStatus: string,
    answers: Array<{ checked: boolean; correct: boolean }>,
  ): void {
    const key = `adler_adaptivity_progress_${worldID}`;
    const progress = this.loadAdaptivityProgressFromLocalStorage(worldID);

    // Initialize element if not exists
    if (!progress[elementID]) {
      progress[elementID] = { tasks: {}, questions: {} };
    }

    // Update question status
    progress[elementID].questions[questionID] = {
      status: questionStatus,
      answers: answers,
    };

    // Update task status
    progress[elementID].tasks[taskID] = {
      status: taskStatus,
    };

    this.localStoragePort.setItem(
      key,
      JSON.stringify({
        worldID,
        elements: progress,
      }),
    );
  }

  /**
   * Checks if a question meets the required difficulty for a task
   */
  private isRequiredQuestionCorrect(
    task: any,
    questionID: number,
    worldID: number,
    elementID: number,
  ): boolean {
    const question = task.adaptivityQuestions.find(
      (q: any) => q.questionId === questionID,
    );
    if (!question) return false;

    const taskDifficulty = task.requiredDifficulty;
    const questionDifficulty = question.questionDifficulty;

    if (taskDifficulty === undefined || questionDifficulty === undefined) {
      return false;
    }

    // Check if question difficulty meets or exceeds required difficulty
    if (questionDifficulty < taskDifficulty) {
      return false;
    }

    // Check if question is correctly answered in progress
    const progress = this.loadAdaptivityProgressFromLocalStorage(worldID);
    const elementProgress = progress[elementID];
    if (!elementProgress) return false;

    const questionStatus = elementProgress.questions[questionID]?.status;
    return questionStatus === "Correct";
  }

  /**
   * Checks if all required tasks are complete for an adaptivity element
   */
  private areAllRequiredTasksComplete(
    element: any,
    worldID: number,
    elementID: number,
  ): boolean {
    const progress = this.loadAdaptivityProgressFromLocalStorage(worldID);
    const elementProgress = progress[elementID];
    if (!elementProgress) return false;

    const requiredTasks = element.adaptivityContent.adaptivityTasks.filter(
      (task: any) => task.optional === false,
    );

    return requiredTasks.every((task: any) => {
      const taskStatus = elementProgress.tasks[task.taskId]?.status;
      return taskStatus === "Correct";
    });
  }

  /**
   * Gets world status (completion state)
   * For hybrid backend, progress is loaded from localStorage
   */
  async getWorldStatus(
    userToken: string,
    worldID: number,
  ): Promise<LearningWorldStatusTO> {
    const awt = await this.loadWorldData(worldID);
    const progress = this.loadProgressFromLocalStorage(worldID);

    // Return elements with their completion status from localStorage
    return {
      worldID,
      elements: awt.world.elements.map((element) => ({
        elementID: element.elementId,
        hasScored: progress[element.elementId]?.scored || false,
      })),
    };
  }

  /**
   * Gets element score
   * For hybrid backend, check localStorage for score
   */
  async getElementScore({
    elementID,
    worldID,
  }: ElementDataParams): Promise<LearningElementScoreTO> {
    const progress = this.loadProgressFromLocalStorage(worldID);
    return {
      elementID,
      success: progress[elementID]?.scored || false,
    };
  }

  /**
   * Scores an element
   * For hybrid backend, scoring is persisted to localStorage
   */
  async scoreElement(
    userToken: string,
    elementID: ComponentID,
    courseID: ComponentID,
  ): Promise<boolean> {
    this.logger.log(
      LogLevelTypes.DEBUG,
      `HybridBackendAdapter: scoreElement - Element ${elementID} in World ${courseID}`,
    );
    this.saveProgressToLocalStorage(courseID, elementID, true);
    return true;
  }

  /**
   * Scores H5P element
   * For hybrid backend, scoring is persisted to localStorage based on xAPI evaluation
   * Returns true if the event was processed successfully (even if no scoring occurred)
   * The actual scoring only happens for completed/answered events with positive results
   */
  async scoreH5PElement(data: ScoreH5PElementParams): Promise<boolean> {
    // Basic xAPI evaluation for UI feedback
    const xapiEvent = data.rawH5PEvent;

    const isCompleted =
      xapiEvent.verb?.id === "http://adlnet.gov/expapi/verbs/completed";
    const isAnswered =
      xapiEvent.verb?.id === "http://adlnet.gov/expapi/verbs/answered";

    // Only process scoring for answered/completed events
    if (isAnswered || isCompleted) {
      let scoredSuccessfully = false;
      const result = xapiEvent.result;

      if (result) {
        if (typeof result.success === "boolean") {
          scoredSuccessfully = result.success;
        } else if (result.score && typeof result.score.scaled === "number") {
          scoredSuccessfully = result.score.scaled >= 0.6;
        }
      }

      // Persist the score to localStorage if successful
      if (scoredSuccessfully) {
        this.saveProgressToLocalStorage(data.courseID, data.h5pID, true);
        this.logger.log(
          LogLevelTypes.DEBUG,
          `HybridBackendAdapter: scoreH5PElement - H5P ${data.h5pID} scored successfully`,
        );
      }

      return scoredSuccessfully;
    }

    // For non-scoring events (interacted, progressed, etc.), just return true
    // to indicate the event was processed without error
    return true;
  }

  /**
   * Login user
   * For hybrid backend, no authentication - return dummy token
   */
  async loginUser(userCredentials: UserCredentialParams): Promise<string> {
    this.logger.log(
      LogLevelTypes.INFO,
      `HybridBackendAdapter: Login (no authentication) - User: ${userCredentials.username}`,
    );
    // Return a dummy token
    return "hybrid-dummy-token";
  }

  /**
   * Get adaptivity element question response
   * Validates answers against the adaptivityContent in world.json
   */
  async getAdaptivityElementQuestionResponse(
    userToken: string,
    worldID: number,
    submissionData: AdaptivityElementQuestionSubmissionTO,
  ): Promise<AdaptivityElementQuestionResponse> {
    // Load world data
    const awt = await this.loadWorldData(worldID);

    // Find the adaptivity element
    const element = awt.world.elements.find(
      (el: any) => el.elementId === submissionData.elementID,
    ) as any;

    if (!element || !element.adaptivityContent) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `Adaptivity element ${submissionData.elementID} not found`,
      );
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Find the task
    const task = element.adaptivityContent.adaptivityTasks.find(
      (t: any) => t.taskId === submissionData.taskID,
    );

    if (!task) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `Task ${submissionData.taskID} not found`,
      );
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Find the question
    const question = task.adaptivityQuestions.find(
      (q: any) => q.questionId === submissionData.questionID,
    );

    if (!question) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `Question ${submissionData.questionID} not found`,
      );
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Validate user answers
    const choices = question.choices || [];
    let isCorrect = true;
    const gradedAnswers: Array<{ checked: boolean; correct: boolean }> = [];

    submissionData.selectedAnswers.forEach((selected, index) => {
      if (index >= choices.length) {
        gradedAnswers.push({ checked: selected, correct: false });
        if (selected) isCorrect = false;
        return;
      }

      const choice = choices[index];
      const shouldBeSelected = choice.isCorrect === true;

      gradedAnswers.push({
        checked: selected,
        correct: shouldBeSelected,
      });

      // For correct answer: selected must match shouldBeSelected
      if (selected !== shouldBeSelected) {
        isCorrect = false;
      }
    });

    // Determine question status
    const questionStatus = isCorrect ? "Correct" : "Incorrect";

    // Check if task was already completed before
    const progress = this.loadAdaptivityProgressFromLocalStorage(worldID);
    const elementProgress = progress[submissionData.elementID];
    const previousTaskStatus =
      elementProgress?.tasks[submissionData.taskID]?.status;

    // Determine task status based on required difficulty
    let taskStatus = previousTaskStatus === "Correct" ? "Correct" : "Incorrect";

    if (isCorrect) {
      // Save progress first
      this.saveAdaptivityProgressToLocalStorage(
        worldID,
        submissionData.elementID,
        submissionData.taskID,
        submissionData.questionID,
        questionStatus,
        taskStatus, // Keep previous status if already correct
        gradedAnswers,
      );

      // Check if the task is complete (required difficulty met)
      const isTaskComplete = this.isRequiredQuestionCorrect(
        task,
        submissionData.questionID,
        worldID,
        submissionData.elementID,
      );

      if (isTaskComplete) {
        taskStatus = "Correct";
        // Update task status in localStorage
        this.saveAdaptivityProgressToLocalStorage(
          worldID,
          submissionData.elementID,
          submissionData.taskID,
          submissionData.questionID,
          questionStatus,
          taskStatus,
          gradedAnswers,
        );
      }
    } else {
      // Save incorrect answer, but keep task status if it was already correct
      this.saveAdaptivityProgressToLocalStorage(
        worldID,
        submissionData.elementID,
        submissionData.taskID,
        submissionData.questionID,
        questionStatus,
        taskStatus, // Keep task status (might be "Correct" from a previous answer)
        gradedAnswers,
      );
    }

    // Check if all required tasks are complete
    const allRequiredTasksComplete = this.areAllRequiredTasksComplete(
      element,
      worldID,
      submissionData.elementID,
    );

    return {
      elementScore: {
        elementId: submissionData.elementID,
        success: allRequiredTasksComplete,
      },
      gradedTask: {
        taskId: submissionData.taskID,
        taskStatus: taskStatus,
      },
      gradedQuestion: {
        id: submissionData.questionID,
        status: questionStatus,
        answers: gradedAnswers,
      },
    };
  }

  /**
   * Helper method to return default adaptivity response
   */
  private getDefaultAdaptivityResponse(
    submissionData: AdaptivityElementQuestionSubmissionTO,
    isCorrect: boolean,
  ): AdaptivityElementQuestionResponse {
    return {
      elementScore: {
        elementId: submissionData.elementID,
        success: isCorrect,
      },
      gradedTask: {
        taskId: submissionData.taskID,
        taskStatus: isCorrect ? "Correct" : "Incorrect",
      },
      gradedQuestion: {
        id: submissionData.questionID,
        status: isCorrect ? "Correct" : "Incorrect",
        answers: submissionData.selectedAnswers.map((selected) => ({
          checked: selected,
          correct: false,
        })),
      },
    };
  }

  /**
   * Get adaptivity element status
   * For hybrid backend, progress is loaded from localStorage
   */
  async getAdaptivityElementStatusResponse({
    elementID,
    worldID,
  }: ElementDataParams): Promise<AdaptivityElementStatusResponse> {
    // Load world data to get adaptivity structure
    const awt = await this.loadWorldData(worldID!);

    // Find the adaptivity element
    const element = awt.world.elements.find(
      (el: any) => el.elementId === elementID,
    ) as any;

    if (!element || !element.adaptivityContent) {
      // Fallback if element not found
      return {
        element: { elementID, success: false },
        questions: [],
        tasks: [],
      };
    }

    // Load progress from localStorage
    const progress = this.loadAdaptivityProgressFromLocalStorage(worldID!);
    const elementProgress = progress[elementID];

    // Build task structure with status from localStorage
    const tasks = element.adaptivityContent.adaptivityTasks.map(
      (task: any) => ({
        taskId: task.taskId,
        taskStatus:
          elementProgress?.tasks[task.taskId]?.status || "Not Attempted",
      }),
    );

    const questions: Array<{
      id: number;
      status: string;
      answers: Array<{ checked: boolean; correct: boolean }>;
    }> = [];

    element.adaptivityContent.adaptivityTasks.forEach((task: any) => {
      task.adaptivityQuestions.forEach((question: any) => {
        // Get saved answers or default answers
        const savedQuestion = elementProgress?.questions[question.questionId];
        const answers =
          savedQuestion?.answers ||
          (question.choices || []).map(() => ({
            checked: false,
            correct: false,
          }));

        questions.push({
          id: question.questionId,
          status: savedQuestion?.status || "Not Attempted",
          answers: answers,
        });
      });
    });

    // Check if all required tasks are complete
    const allRequiredTasksComplete = elementProgress
      ? this.areAllRequiredTasksComplete(element, worldID!, elementID)
      : false;

    return {
      element: {
        elementID,
        success: allRequiredTasksComplete,
      },
      questions,
      tasks,
    };
  }

  /**
   * Get avatar configuration
   * For hybrid backend, load from localStorage or return default
   */
  async getAvatarConfig(userToken: string): Promise<BackendAvatarConfigTO> {
    const key = "adler_avatar_config";
    const stored = this.localStoragePort.getItem(key);

    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        this.logger.log(
          LogLevelTypes.DEBUG,
          "HybridBackendAdapter: getAvatarConfig - loaded from localStorage",
        );
        return Object.assign(new BackendAvatarConfigTO(), parsed);
      } catch (error) {
        this.logger.log(
          LogLevelTypes.ERROR,
          `Failed to parse avatar config from localStorage: ${error}`,
        );
      }
    }

    this.logger.log(
      LogLevelTypes.DEBUG,
      "HybridBackendAdapter: getAvatarConfig - returning default avatar",
    );

    // Return default avatar configuration
    const config = new BackendAvatarConfigTO();

    // Face (texture names)
    config.eyes = "Neural_Eyes_1";
    config.nose = "Nose_1";
    config.mouth = "Mouth_1";
    config.eyebrows = "Brows_1";

    // Hair
    config.hair = "hair-short-vanilla";
    config.beard = "none";
    config.hairColor = 8;

    // Accessories
    config.headgear = "none";
    config.glasses = "none";
    config.backpack = "none";
    config.other = "none";

    // Clothes
    config.shirt = "shirts-hoodie";
    config.shirtColor = 0;
    config.pants = "pants-jeans";
    config.pantsColor = 0;
    config.shoes = "shoes-trainers";
    config.shoesColor = 0;

    // Body
    config.skinColor = 24;
    config.roundness = 0.5;

    return config;
  }

  /**
   * Update avatar configuration
   * For hybrid backend, save to localStorage
   */
  async updateAvatarConfig(
    userToken: string,
    avatarConfig: BackendAvatarConfigTO,
  ): Promise<boolean> {
    const key = "adler_avatar_config";
    try {
      this.localStoragePort.setItem(key, JSON.stringify(avatarConfig));
      this.logger.log(
        LogLevelTypes.DEBUG,
        "HybridBackendAdapter: updateAvatarConfig - saved to localStorage",
      );
      return true;
    } catch (error) {
      this.logger.log(
        LogLevelTypes.ERROR,
        `Failed to save avatar config to localStorage: ${error}`,
      );
      return false;
    }
  }
}
