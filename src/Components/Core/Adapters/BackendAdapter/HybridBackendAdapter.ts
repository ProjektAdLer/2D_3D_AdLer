import { inject, injectable } from "inversify";
import IBackendPort, {
  ElementDataParams,
  GetWorldDataParams,
  ScoreH5PElementParams,
  UserCredentialParams,
} from "../../Application/Ports/Interfaces/IBackendPort";
import BackendWorldTO from "../../Application/DataTransferObjects/BackendWorldTO";
import CourseListTO from "../../Application/DataTransferObjects/CourseListTO";
import LearningElementScoreTO from "../../Application/DataTransferObjects/LearningElementScoreTO";
import LearningWorldStatusTO from "../../Application/DataTransferObjects/LearningWorldStatusTO";
import AdaptivityElementQuestionSubmissionTO from "../../Application/DataTransferObjects/AdaptivityElement/AdaptivityElementQuestionSubmissionTO";
import AdaptivityElementQuestionResponse from "./Types/AdaptivityElementQuestionResponse";
import AdaptivityElementStatusResponse from "./Types/AdaptivityElementStatusResponse";
import { BackendAvatarConfigTO } from "../../Application/DataTransferObjects/BackendAvatarConfigTO";
import BackendAdapterUtils from "./BackendAdapterUtils";
import AWT from "./Types/AWT";
import { ComponentID } from "../../Domain/Types/EntityTypes";
import PORT_TYPES from "../../DependencyInjection/Ports/PORT_TYPES";
import type ILocalStoragePort from "../../Application/Ports/Interfaces/ILocalStoragePort";
import type IWorldStorageAdapter from "../../Application/Ports/WorldStoragePort/IWorldStorageAdapter";

/**
 * WorldsIndex structure as generated by extractLearningWorlds.js
 */
interface WorldsIndex {
  worlds: Array<{
    worldID: number;
    worldName: string;
    worldFolder: string;
    description?: string;
    elementCount?: number;
  }>;
}

/**
 * HybridBackendAdapter
 *
 * Hybrid offline-first backend adapter that:
 * 1. First checks IndexedDB (LocalStore) for cached learning worlds
 * 2. Falls back to public/LearningWorlds/ directory if not found in cache
 *
 * This adapter replaces FileBasedBackendAdapter and provides seamless offline support
 * with runtime MBZ import capability via the browser.
 *
 * Structure:
 * - IndexedDB (LocalStore): Imported worlds via MBZ files
 * - public/LearningWorlds/: Pre-extracted worlds from build time
 *
 * This adapter implements IBackendPort and provides a hybrid file-based alternative
 * to the real BackendAdapter (API) and MockBackendAdapter (hardcoded data).
 */
@injectable()
export default class HybridBackendAdapter implements IBackendPort {
  private worldsIndex: WorldsIndex | null = null;
  private worldCache: Map<number, AWT> = new Map();
  private baseUrl: string;

  constructor(
    @inject(PORT_TYPES.ILocalStoragePort)
    private localStoragePort: ILocalStoragePort,
    @inject(PORT_TYPES.IWorldStorageAdapter)
    private worldStorage: IWorldStorageAdapter,
  ) {
    // Base URL for fetching files from public folder
    const publicUrl = process.env.PUBLIC_URL || "";
    this.baseUrl = window.location.origin + publicUrl + "/LearningWorlds/";

    // Initialize WorldStorageAdapter for IndexedDB access
    this.worldStorage.init().catch((error) => {
      console.error(
        "HybridBackendAdapter: Failed to initialize WorldStorageAdapter:",
        error,
      );
    });
  }

  /**
   * Loads the worlds.json index file from public folder
   */
  private async loadWorldsIndex(): Promise<void> {
    if (this.worldsIndex) return; // Already loaded

    try {
      const response = await fetch(this.baseUrl + "worlds.json");
      if (!response.ok) {
        throw new Error(
          `Failed to load worlds.json: ${response.status} ${response.statusText}`,
        );
      }
      this.worldsIndex = await response.json();
    } catch (error) {
      console.error("HybridBackendAdapter: Error loading worlds.json", error);
      // Fallback: empty worlds list
      this.worldsIndex = { worlds: [] };
    }
  }

  /**
   * Loads a world.json - HYBRID: Try IndexedDB first, then public folder
   */
  private async loadWorldData(worldID: number): Promise<AWT> {
    // Check cache first
    if (this.worldCache.has(worldID)) {
      return this.worldCache.get(worldID)!;
    }

    // Step 1: Try loading from IndexedDB
    try {
      const worldExists = await this.worldStorage.worldExists(worldID);

      if (worldExists) {
        console.log(
          `HybridBackendAdapter: Loading world ${worldID} from IndexedDB`,
        );
        const worldBlob = await this.worldStorage.getFile(
          worldID,
          "world.json",
        );

        if (worldBlob) {
          const worldText = await worldBlob.text();
          const awt: AWT = JSON.parse(worldText);

          // Cache it
          this.worldCache.set(worldID, awt);
          return awt;
        }
      }
    } catch (error) {
      console.warn(
        `HybridBackendAdapter: Failed to load from IndexedDB, falling back to public folder`,
        error,
      );
    }

    // Step 2: Fallback to public folder
    console.log(
      `HybridBackendAdapter: Loading world ${worldID} from public folder`,
    );
    await this.loadWorldsIndex();

    const worldInfo = this.worldsIndex!.worlds.find(
      (w) => w.worldID === worldID,
    );

    if (!worldInfo) {
      throw new Error(
        `World with ID ${worldID} not found in worlds.json or IndexedDB. Available worlds: ${this.worldsIndex!.worlds.map((w) => w.worldID).join(", ")}`,
      );
    }

    // Fetch world.json from public folder
    const worldUrl = this.baseUrl + worldInfo.worldFolder + "/world.json";

    try {
      const response = await fetch(worldUrl);
      if (!response.ok) {
        throw new Error(
          `Failed to load world.json for world ${worldID}: ${response.status} ${response.statusText}`,
        );
      }

      const awt: AWT = await response.json();

      // Cache it
      this.worldCache.set(worldID, awt);

      return awt;
    } catch (error) {
      console.error(
        `HybridBackendAdapter: Error loading world ${worldID}`,
        error,
      );
      throw error;
    }
  }

  /**
   * Gets the element source path/URL - HYBRID: Try IndexedDB first, then public folder
   */
  async getElementSource({
    worldID,
    elementID,
  }: ElementDataParams): Promise<string> {
    // Load world data to check element type
    const awt = await this.loadWorldData(worldID);

    // Find element in AWT
    const element = awt.world.elements.find((el) => el.elementId === elementID);

    if (!element) {
      throw new Error(`Element ${elementID} not found in world ${worldID}`);
    }

    // Check if external URL (LearningElement type has url field)
    const elementWithUrl = element as any;
    if (elementWithUrl.url && elementWithUrl.url.startsWith("http")) {
      return elementWithUrl.url;
    }

    // Adaptivity elements have no separate file - content is embedded in world.json
    if (
      element.elementCategory === "adaptivity" ||
      element.elementFileType === "adaptivity"
    ) {
      return "";
    }

    // Step 1: Try loading from IndexedDB
    try {
      const worldExists = await this.worldStorage.worldExists(worldID);

      if (worldExists) {
        let elementPath: string;

        // Check if H5P (folder) or regular file
        if (
          element.elementCategory === "h5p" ||
          element.elementCategory === "primitiveH5P" ||
          element.elementFileType === "h5p"
        ) {
          // For H5P, we need to check if the folder exists by looking for index.html
          elementPath = `elements/${elementID}/index.html`;
        } else {
          // Regular files
          elementPath = `elements/${elementID}.${element.elementFileType}`;
        }

        const fileBlob = await this.worldStorage.getFile(worldID, elementPath);

        if (fileBlob) {
          console.log(
            `HybridBackendAdapter: Element ${elementID} loaded from IndexedDB`,
          );

          // Create object URL for the blob
          const objectUrl = URL.createObjectURL(fileBlob);

          // For H5P, return the folder path (without index.html)
          if (
            element.elementCategory === "h5p" ||
            element.elementCategory === "primitiveH5P" ||
            element.elementFileType === "h5p"
          ) {
            // Return base path - the H5P viewer will handle it
            // Note: This may need adjustment depending on how H5P viewer works with blob URLs
            return objectUrl;
          }

          return objectUrl;
        }
      }
    } catch (error) {
      console.warn(
        `HybridBackendAdapter: Failed to load element ${elementID} from IndexedDB, falling back to public folder`,
        error,
      );
    }

    // Step 2: Fallback to public folder
    console.log(
      `HybridBackendAdapter: Element ${elementID} loaded from public folder`,
    );

    // Ensure we have world info
    await this.loadWorldsIndex();
    const worldInfo = this.worldsIndex!.worlds.find(
      (w) => w.worldID === worldID,
    );

    if (!worldInfo) {
      throw new Error(`World ${worldID} not found`);
    }

    const elementsPath = this.baseUrl + worldInfo.worldFolder + "/elements/";

    // Check if H5P (folder) or regular file
    if (
      element.elementCategory === "h5p" ||
      element.elementCategory === "primitiveH5P" ||
      element.elementFileType === "h5p"
    ) {
      // H5P elements are folders
      return elementsPath + elementID;
    }

    // Regular files
    return elementsPath + elementID + "." + element.elementFileType;
  }

  /**
   * Gets available courses/worlds for the user - HYBRID: Merge IndexedDB + public folder
   */
  async getCoursesAvailableForUser(userToken: string): Promise<CourseListTO> {
    await this.loadWorldsIndex();

    // Get worlds from public folder
    const publicWorlds = this.worldsIndex!.worlds.map((world) => ({
      courseID: world.worldID,
      courseName: world.worldName,
    }));

    // Get worlds from IndexedDB
    try {
      const indexedDBWorlds = await this.worldStorage.getAllWorlds();
      const indexedDBCourses = indexedDBWorlds.map((world) => ({
        courseID: world.worldID,
        courseName: world.worldName,
      }));

      // Merge and deduplicate by courseID
      const allCourses = [...publicWorlds, ...indexedDBCourses];
      const uniqueCourses = allCourses.filter(
        (course, index, self) =>
          index === self.findIndex((c) => c.courseID === course.courseID),
      );

      return { courses: uniqueCourses };
    } catch (error) {
      console.warn(
        "HybridBackendAdapter: Failed to load worlds from IndexedDB",
        error,
      );
      // Fallback to public worlds only
      return { courses: publicWorlds };
    }
  }

  /**
   * Gets world data (AWT)
   */
  async getWorldData({ worldID }: GetWorldDataParams): Promise<BackendWorldTO> {
    const awt = await this.loadWorldData(worldID);

    // Use existing parser from BackendAdapterUtils
    return BackendAdapterUtils.parseAWT(awt);
  }

  /**
   * Load progress from localStorage for a specific world
   */
  private loadProgressFromLocalStorage(worldID: number): {
    [elementID: number]: { scored: boolean; timestamp: string };
  } {
    const key = `adler_progress_${worldID}`;
    const stored = this.localStoragePort.getItem(key);
    if (!stored) {
      return {};
    }
    try {
      const parsed = JSON.parse(stored);
      return parsed.elements || {};
    } catch (error) {
      console.error("Failed to parse progress from localStorage:", error);
      return {};
    }
  }

  /**
   * Save progress to localStorage for a specific world
   */
  private saveProgressToLocalStorage(
    worldID: number,
    elementID: number,
    scored: boolean,
  ): void {
    const key = `adler_progress_${worldID}`;
    const progress = this.loadProgressFromLocalStorage(worldID);
    progress[elementID] = {
      scored,
      timestamp: new Date().toISOString(),
    };
    this.localStoragePort.setItem(
      key,
      JSON.stringify({
        worldID,
        elements: progress,
      }),
    );
  }

  /**
   * Gets world status (completion state)
   * For hybrid backend, progress is loaded from localStorage
   */
  async getWorldStatus(
    userToken: string,
    worldID: number,
  ): Promise<LearningWorldStatusTO> {
    const awt = await this.loadWorldData(worldID);
    const progress = this.loadProgressFromLocalStorage(worldID);

    // Return elements with their completion status from localStorage
    return {
      worldID,
      elements: awt.world.elements.map((element) => ({
        elementID: element.elementId,
        hasScored: progress[element.elementId]?.scored || false,
      })),
    };
  }

  /**
   * Gets element score
   * For hybrid backend, check localStorage for score
   */
  async getElementScore({
    elementID,
    worldID,
  }: ElementDataParams): Promise<LearningElementScoreTO> {
    const progress = this.loadProgressFromLocalStorage(worldID);
    return {
      elementID,
      success: progress[elementID]?.scored || false,
    };
  }

  /**
   * Scores an element
   * For hybrid backend, scoring is persisted to localStorage
   */
  async scoreElement(
    userToken: string,
    elementID: ComponentID,
    courseID: ComponentID,
  ): Promise<boolean> {
    console.log(
      `HybridBackendAdapter: scoreElement - Element ${elementID} in World ${courseID}`,
    );
    this.saveProgressToLocalStorage(courseID, elementID, true);
    return true;
  }

  /**
   * Scores H5P element
   * For hybrid backend, scoring is not persisted
   */
  async scoreH5PElement(data: ScoreH5PElementParams): Promise<boolean> {
    console.log(
      `HybridBackendAdapter: scoreH5PElement called (not persisted) - H5P ${data.h5pID}`,
    );

    // Basic xAPI evaluation for UI feedback
    const xapiEvent = data.rawH5PEvent;

    const isCompleted =
      xapiEvent.verb?.id === "http://adlnet.gov/expapi/verbs/completed";
    const isAnswered =
      xapiEvent.verb?.id === "http://adlnet.gov/expapi/verbs/answered";

    if (isAnswered || isCompleted) {
      const result = xapiEvent.result;
      if (result) {
        if (typeof result.success === "boolean") {
          return result.success;
        }
        if (result.score && typeof result.score.scaled === "number") {
          return result.score.scaled >= 0.6;
        }
      }
    }

    return false;
  }

  /**
   * Login user
   * For hybrid backend, no authentication - return dummy token
   */
  async loginUser(userCredentials: UserCredentialParams): Promise<string> {
    console.log(
      `HybridBackendAdapter: Login (no authentication) - User: ${userCredentials.username}`,
    );
    // Return a dummy token
    return "hybrid-dummy-token";
  }

  /**
   * Get adaptivity element question response
   * Validates answers against the adaptivityContent in world.json
   */
  async getAdaptivityElementQuestionResponse(
    userToken: string,
    worldID: number,
    submissionData: AdaptivityElementQuestionSubmissionTO,
  ): Promise<AdaptivityElementQuestionResponse> {
    // Load world data
    const awt = await this.loadWorldData(worldID);

    // Find the adaptivity element
    const element = awt.world.elements.find(
      (el: any) => el.elementId === submissionData.elementID,
    ) as any;

    if (!element || !element.adaptivityContent) {
      console.error(`Adaptivity element ${submissionData.elementID} not found`);
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Find the task
    const task = element.adaptivityContent.adaptivityTasks.find(
      (t: any) => t.taskId === submissionData.taskID,
    );

    if (!task) {
      console.error(`Task ${submissionData.taskID} not found`);
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Find the question
    const question = task.adaptivityQuestions.find(
      (q: any) => q.questionId === submissionData.questionID,
    );

    if (!question) {
      console.error(`Question ${submissionData.questionID} not found`);
      return this.getDefaultAdaptivityResponse(submissionData, false);
    }

    // Validate user answers
    const choices = question.choices || [];
    let isCorrect = true;
    const gradedAnswers: Array<{ checked: boolean; correct: boolean }> = [];

    submissionData.selectedAnswers.forEach((selected, index) => {
      if (index >= choices.length) {
        gradedAnswers.push({ checked: selected, correct: false });
        if (selected) isCorrect = false;
        return;
      }

      const choice = choices[index];
      const shouldBeSelected = choice.isCorrect === true;

      gradedAnswers.push({
        checked: selected,
        correct: shouldBeSelected,
      });

      // For correct answer: selected must match shouldBeSelected
      if (selected !== shouldBeSelected) {
        isCorrect = false;
      }
    });

    return {
      elementScore: {
        elementId: submissionData.elementID,
        success: isCorrect,
      },
      gradedTask: {
        taskId: submissionData.taskID,
        taskStatus: isCorrect ? "Correct" : "Incorrect",
      },
      gradedQuestion: {
        id: submissionData.questionID,
        status: isCorrect ? "Correct" : "Incorrect",
        answers: gradedAnswers,
      },
    };
  }

  /**
   * Helper method to return default adaptivity response
   */
  private getDefaultAdaptivityResponse(
    submissionData: AdaptivityElementQuestionSubmissionTO,
    isCorrect: boolean,
  ): AdaptivityElementQuestionResponse {
    return {
      elementScore: {
        elementId: submissionData.elementID,
        success: isCorrect,
      },
      gradedTask: {
        taskId: submissionData.taskID,
        taskStatus: isCorrect ? "Correct" : "Incorrect",
      },
      gradedQuestion: {
        id: submissionData.questionID,
        status: isCorrect ? "Correct" : "Incorrect",
        answers: submissionData.selectedAnswers.map((selected) => ({
          checked: selected,
          correct: false,
        })),
      },
    };
  }

  /**
   * Get adaptivity element status
   * For hybrid backend, progress is not persisted, always return fresh state
   */
  async getAdaptivityElementStatusResponse({
    elementID,
    worldID,
  }: ElementDataParams): Promise<AdaptivityElementStatusResponse> {
    // Load world data to get adaptivity structure
    const awt = await this.loadWorldData(worldID!);

    // Find the adaptivity element
    const element = awt.world.elements.find(
      (el: any) => el.elementId === elementID,
    ) as any;

    if (!element || !element.adaptivityContent) {
      // Fallback if element not found
      return {
        element: { elementID, success: false },
        questions: [],
        tasks: [],
      };
    }

    // Build task and question structure with "Not Attempted" status
    const tasks = element.adaptivityContent.adaptivityTasks.map(
      (task: any) => ({
        taskId: task.taskId,
        taskStatus: "Not Attempted",
      }),
    );

    const questions: Array<{
      id: number;
      status: string;
      answers: Array<{ checked: boolean; correct: boolean }>;
    }> = [];

    element.adaptivityContent.adaptivityTasks.forEach((task: any) => {
      task.adaptivityQuestions.forEach((question: any) => {
        // Create default answers array based on number of choices
        const defaultAnswers = (question.choices || []).map(() => ({
          checked: false,
          correct: false,
        }));

        questions.push({
          id: question.questionId,
          status: "Not Attempted",
          answers: defaultAnswers,
        });
      });
    });

    return {
      element: {
        elementID,
        success: false,
      },
      questions,
      tasks,
    };
  }

  /**
   * Get avatar configuration
   * For hybrid backend, load from localStorage or return default
   */
  async getAvatarConfig(userToken: string): Promise<BackendAvatarConfigTO> {
    const key = "adler_avatar_config";
    const stored = this.localStoragePort.getItem(key);

    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        console.log(
          "HybridBackendAdapter: getAvatarConfig - loaded from localStorage",
        );
        return Object.assign(new BackendAvatarConfigTO(), parsed);
      } catch (error) {
        console.error(
          "Failed to parse avatar config from localStorage:",
          error,
        );
      }
    }

    console.log(
      "HybridBackendAdapter: getAvatarConfig - returning default avatar",
    );

    // Return default avatar configuration
    const config = new BackendAvatarConfigTO();

    // Face (texture names)
    config.eyes = "Neural_Eyes_1";
    config.nose = "Nose_1";
    config.mouth = "Mouth_1";
    config.eyebrows = "Brows_1";

    // Hair
    config.hair = "hair-short-vanilla";
    config.beard = "none";
    config.hairColor = 8;

    // Accessories
    config.headgear = "none";
    config.glasses = "none";
    config.backpack = "none";
    config.other = "none";

    // Clothes
    config.shirt = "shirts-hoodie";
    config.shirtColor = 0;
    config.pants = "pants-jeans";
    config.pantsColor = 0;
    config.shoes = "shoes-trainers";
    config.shoesColor = 0;

    // Body
    config.skinColor = 24;
    config.roundness = 0.5;

    return config;
  }

  /**
   * Update avatar configuration
   * For hybrid backend, save to localStorage
   */
  async updateAvatarConfig(
    userToken: string,
    avatarConfig: BackendAvatarConfigTO,
  ): Promise<boolean> {
    const key = "adler_avatar_config";
    try {
      this.localStoragePort.setItem(key, JSON.stringify(avatarConfig));
      console.log(
        "HybridBackendAdapter: updateAvatarConfig - saved to localStorage",
      );
      return true;
    } catch (error) {
      console.error("Failed to save avatar config to localStorage:", error);
      return false;
    }
  }
}
